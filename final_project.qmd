---
title: "Final Project: Data Science Culmination Project"
format: pdf
---

\noindent Project Proposal: Week of November 18th-22nd

\noindent Project Due: Our Final Exam Time.

```{r}
#| label: install packages

# install.packages("rvest")
library("rvest")
library("tidyverse")
```


## Assignment Description

This is it! This is the culmination of all your work in both of the data science courses! The parameters of this project are very general because I want to give you the chance to explore your interests and be creative. Generally, your project will go through the entire data science process. The project will involve a formal written document as well as a presentation. The written document will be worth 2/3rd's of the final grade and the presentation will be worth the other 1/3rd. 


Here are the sections on how the project will be evaluated (A rubric will be released later with more specific parameters).

* Questions and Goals: The questions you wish to answer and the goals of the project. You should have multiple questions that you answer in the project. Not all of them need to be questions that require modeling to answer, but some of them need to be.
* Data Acquisition: The project describes how the data was obtained and gives substantial backround on the data. 
* Data Preprocessing: Throughout the project, the proper preprocessing techniques (variable transformations, reshaping data, etc.) are utilized.
* Exploratory Data Analysis: Proper exploratory plots and summarizes are utilized to describe the data and showcase certain interesting aspects of the data that you will explore later in the project.
* Modeling and Analysis: This is a large portion of the project! You work toward answer the questions/goals you stated at the beginning. Your project needs to include at least 3 modeling techniques we discussed in class. You will fit, tune, and compare the methods. You will discuss the results and why they make sense in context. This section can include a wide range of modeling techniques. Your proposal should be focused on describing what you want to do in this section.
* Data Product: You present your data, models, and conclusions in a professional manner. This could include an interactive data product.



## Place Work Below!!

# The Dataset

We're using the "Collections" dataset from the Museum of Modern Art (MoMA), which actually comes as 2 separate datasets: "Artists" and "Artworks". The observations in Artworks include both the artist's name and their constituentID, which are both variables in the Artists dataset. So, we're gonna start by just merging the two together. The data types between the two sets are different, so we also have to do some wrangling first.

Many of the artists have missing nationality and/or biography information, despite the information being readily available; this is presumably just because the information wasn't included in the MoMA page. To counter this, we (are trying to) scrape information about different artists to reference with our missing nationalities.
```{r}
#| label: load & tidy data

# shared variables: ConstituentID, DisplayName (Artist), ArtistBio, Nationality, Gender,
# BeginDate, EndDate, 

Artists <- read_csv("Artists.zip")

artists <- Artists %>% 
  mutate(ConstituentID = as.character(ConstituentID))

artworks <- full_join(artists, Artworks, by = join_by(ConstituentID, DisplayName == Artist)) %>% 
  mutate(Date = as.integer(str_extract(Date, "\\d{4}")))

Artists %>% 
  filter(is.na(Nationality))

Artworks %>% 
  filter(ConstituentID == 2)
```

# EDA

As part of our EDA and data tidying, we need to consider which wars were going on when each piece was created. To start, just reference the oldest and most recent pieces:
```{r}
#| label: oldest work

Artworks %>% 
  drop_na(Date) %>% 
  mutate(Date = str_extract(Date, "\\d{4}")) %>% 
  arrange(Date)
```

The oldest work here is from 1768. To add our new column, we first need a list of all wars fought since 1768. Thankfully, Wikipedia has well-organized tables with this information: https://en.wikipedia.org/wiki/Category:Lists_of_wars_by_date
We need to start by scraping the relevant pages, and extracting the tables into usable objects:
```{r}
# start by just saving the urls, so it's more manageable lengthwise
#| label: scrape war data

wars_1500_1799_url <- "https://en.wikipedia.org/wiki/List_of_wars:_1500%E2%80%931799"
wars_1800_1899_url <- "https://en.wikipedia.org/wiki/List_of_wars:_1800%E2%80%931899"
wars_1900_1944_url <- "https://en.wikipedia.org/wiki/List_of_wars:_1900%E2%80%931944"
wars_1945_1989_url <- "https://en.wikipedia.org/wiki/List_of_wars:_1945%E2%80%931989"
wars_1990_2002_url <- "https://en.wikipedia.org/wiki/List_of_wars:_1990%E2%80%932002"
wars_2003_2019_url <- "https://en.wikipedia.org/wiki/List_of_wars:_2003%E2%80%932019"
wars_2020_now_url <- "https://en.wikipedia.org/wiki/List_of_wars:_2020%E2%80%93present"

# now read the html files using rvest
wars_1500_1799_html <- read_html(wars_1500_1799_url)
wars_1800_1899_html <- read_html(wars_1800_1899_url)
wars_1900_1944_html <- read_html(wars_1900_1944_url)
wars_1945_1989_html <- read_html(wars_1945_1989_url)
wars_1990_2002_html <- read_html(wars_1990_2002_url)
wars_2003_2019_html <- read_html(wars_2003_2019_url)
wars_2020_now_html <- read_html(wars_2020_now_url)

# we need to split our datasets up into decades, since that's how the data is stored
# aka, extract the actual tables

# 1700s #
wars_1700_1799 <- wars_1500_1799_html %>% 
  html_elements(".wikitable") %>% 
  html_table
wars_1700_1799 <- wars_1700_1799[[3]]

# 1800s #
wars_1800_1899 <- wars_1800_1899_html %>% 
  html_elements("table.wikitable.sortable") %>% 
  html_table
wars_1800_1809 <- wars_1800_1899[[1]]
wars_1810_1819 <- wars_1800_1899[[2]]
wars_1820_1829 <- wars_1800_1899[[3]]
wars_1830_1839 <- wars_1800_1899[[4]]
wars_1840_1849 <- wars_1800_1899[[5]]
wars_1850_1859 <- wars_1800_1899[[6]]
wars_1860_1869 <- wars_1800_1899[[7]]
wars_1870_1879 <- wars_1800_1899[[8]]
wars_1880_1889 <- wars_1800_1899[[9]]
wars_1890_1899 <- wars_1800_1899[[10]]

# first half of the 1900s #
wars_1900_1944 <- wars_1900_1944_html %>% 
  html_elements("table.wikitable.sortable") %>% 
  html_table
wars_1900_1909 <- wars_1900_1944[[1]]
wars_1910_1919 <- wars_1900_1944[[2]]
wars_1920_1929 <- wars_1900_1944[[3]]
wars_1930_1944 <- wars_1900_1944[[4]]

# second half of the 1900s #
wars_1945_1989 <- wars_1945_1989_html %>% 
  html_elements("table.wikitable.sortable") %>% 
  html_table
wars_1945_1949 <- wars_1945_1989[[1]]
wars_1950_1959 <- wars_1945_1989[[2]]
wars_1960_1969 <- wars_1945_1989[[3]]
wars_1970_1979 <- wars_1945_1989[[4]]
wars_1980_1989 <- wars_1945_1989[[5]]

# the 90s #
wars_1990_2002 <- wars_1990_2002_html %>% 
  html_element("table.wikitable") %>% 
  html_table

# 2003 to 2019
wars_2003_2019 <- wars_2003_2019_html %>% 
  html_elements("table.wikitable.sortable") %>% 
  html_table
wars_2003 <- wars_2003_2019[[1]] # this one will need some cleaning
wars_2004 <- wars_2003_2019[[2]]
wars_2005 <- wars_2003_2019[[3]]
wars_2006_2009 <- wars_2003_2019[[4]]
wars_2010_2019 <- wars_2003_2019[[5]]

# 2020 to today
wars_2020_now <- wars_2020_now_html %>% 
  html_element("table.wikitable.sortable") %>% 
  html_table
```

Our next problem is tidying these new datasets (and perhaps combining them down into one). The biggest problem is the "belligerents" column(s); there's all sorts of formatting within the column, and countries might not be listed under the same names as our other datasets. Let's look at our nationalities to see:

```{r}
#| label: count nationalities

Artists %>% 
  group_by(Nationality) %>% 
  count()

Artists %>% 
  filter(Nationality == "Caribbean")
```

We can use this as a guideline for which names to use as we tidy the wars datasets. For now, let's start by binding all of our wars together into one big list, and fixing the notation on it:
```{r}
#| label: combining war datasets

# the lists for 1945 onward use different naming syntax
# but we also can't use rename() when columns have identical names
# so instead, we make a 1945 to now dataset and rename that one!

wars_1945_now <- bind_rows(list(
  wars_1945_1949,
  wars_1950_1959,
  wars_1960_1969,
  wars_1970_1979,
  wars_1980_1989,
  wars_1990_2002,
  wars_2003,
  wars_2004,
  wars_2005,
  wars_2006_2009,
  wars_2010_2019,
  wars_2020_now
))

# the 1990-2002 has a random capital c on "Name of Conflict", so we have
# to be tricky to rename it
wars_1945_now <- wars_1945_now %>% 
  mutate("Conflict Name" = coalesce(wars_1945_now$"Name of conflict", wars_1945_now$"Name of Conflict")) %>% 
  select(-c("Name of Conflict", "Name of conflict")) %>% 
  rename("Name of Conflict" = "Conflict Name",
         Start = Started,
         Finish = Ended,
         Victorious = Belligerents...4,
         Defeated = Belligerents...5) %>% 
  filter(Start != "Started")

# since we're already renaming the double "belligerents" columns, we might
# as well pre-merge 1700 to 1944 as well:
wars_1700_1944 <- bind_rows(list(
  wars_1700_1799,
  wars_1800_1809,
  wars_1810_1819,
  wars_1820_1829,
  wars_1830_1839,
  wars_1840_1849,
  wars_1850_1859,
  wars_1860_1869,
  wars_1870_1879,
  wars_1880_1889,
  wars_1890_1899,
  wars_1900_1909,
  wars_1910_1919,
  wars_1920_1929,
  wars_1930_1944
))

wars_1700_1944 <- wars_1700_1944 %>% 
  mutate("Conflict Name" = coalesce(wars_1700_1944$"Name of conflict", wars_1700_1944$"Name of Conflict")) %>% 
  select(-c("Name of Conflict", "Name of conflict")) %>% 
  rename("Name of Conflict" = "Conflict Name",
         Victorious = Belligerents...4,
         Defeated = Belligerents...5) %>% 
  filter(Start != "Start")

wars_1700_now <- bind_rows(list(
  wars_1700_1944,
  wars_1945_now
))
```

Part of the problem here is that some values have Wikipedia notes on them, in the form of [note id]. The easiest first step here is to just get rid of those:
```{r}
wars_1700_now %>% 
  mutate(Start_dig = str_extract(Start, "[:digit:]{4}"),
         Finish_dig = str_extract(Finish, "[:digit:]{4}"),
         Matching = Start_dig == Start & Finish_dig == Finish) %>% 
  filter(Matching == FALSE)

wars_1700_now %>% 
  mutate(Start = str_remove(Start, "\\[[[:alnum:]]+\\]"),
         Finish = str_remove(Finish, "\\[[[:alnum:]]+\\]"),
         # extract capital letters followed by more letters (aka, proper nouns/names)
         Victorious = str_extract_all(Victorious, "[:upper:]+[:alpha:]+"),
         # collapse that list into a string to get (roughly) the countries involved
         Victorious = str_c(Victorious),
         # cut out the string stuff so it's just a normal looking list
         Victorious = str_remove_all(Victorious, 'c\\(|\\"|\\)'),
         Defeated = str_extract_all(Defeated, "[:upper:]+[:alpha:]+"),
         Defeated = str_c(Defeated),
         Defeated = str_remove_all(Defeated, 'c\\(|\\"|\\)'),
         "Name of Conflict" = str_remove(wars_1700_now$"Name of Conflict", "\\[[[:alnum:]]+\\]")) %>% 
  arrange(desc(Finish))
```
Now comes the unfortunate part. Our *artists* have nationalities (e.g., "French"), but our *wars* have countries (e.g., "France"). I don't think there's any good way to automate this, unfortunately; we just have to suck it up and make a big list of countries & nationality names:
```{r}
#| label: nationality vs nation list

nations <- c("Afghanistan",
             "Albania",
             "Algeria",
             "United States",
             "Australian Aborigines",
             "Argentina",
             "Australia",
             "Austria",
             "Azerbaijan",
             "Bahamas",
             "Bangladesh",
             "Belgium",
             "Benin",
             "Bolivia",
             "Bosnia",
             "Great Britain",
             "United Kingdom",
             "Bulgaria",
             "Burkina Faso",
             "Cambodia",
             "Cameroon",
             "Canada",
             "Catalonia",
             "Chile",
             "China",
             "Colombia",
             "")
```

Let's maybe try a different approach for now. The World Wars famously impacted, well, the world. Let's just check when the art pieces were made, to see if they were during one of the two world wars:
```{r}
#| label: world wars column

wars_artworks <- artworks %>% 
  mutate(wars = case_when(
    Date < 1914 ~ "Pre WW1",
    between(Date, 1914, 1918) ~ "WW1",
    between(Date, 1918, 1939) ~ "Between wars",
    between(Date, 1939, 1945) ~ "WW2",
    Date > 1945 ~ "Post WW2",
    .default = "None"
  ))
```

Now that we have some simple sorting, let's check if war affects medium at all. I'm thinking "classification" would be a good place to start:

```{r}
#| label: war-classification eda

wars_artworks %>% 
  filter(wars != "None") %>% 
  ggplot(aes(x = Classification)) + geom_bar() +
  facet_grid(vars(wars)) + scale_x_discrete(guide = guide_axis(angle = 45))

wars_artworks %>% 
  filter(wars != "None") %>% 
  # count how many pieces are in each classification/war period combo
  count(wars, Classification) %>% 
  group_by(wars) %>% 
  mutate(n_tot = sum(n), # count how many pieces are in each war period
         prop = n / n_tot * 100, # get what percent of "pieces from this period" each category makes up
         prop = format(prop, scientific = FALSE)) %>% 
  select(wars, Classification, prop) %>%
  pivot_wider(names_from = wars, values_from = prop) %>% # move war periods to columns
  relocate("Between wars", .after = WW1) %>% 
  relocate("Post WW2", .after = WW2) %>% 
  replace_na(list("Pre WW1" = "0", WW1 = "0", "Between wars" = "0", WW2 = "0", "Post WW2" = "0"))
```
